# Copyright (c) 2009 Bram Wijnands
#                                                                     
# Permission is hereby granted, free of charge, to any person         
# obtaining a copy of this software and associated documentation      
# files (the "Software"), to deal in the Software without             
# restriction, including without limitation the rights to use,        
# copy, modify, merge, publish, distribute, sublicense, and/or sell   
# copies of the Software, and to permit persons to whom the           
# Software is furnished to do so, subject to the following      
# conditions:
# 
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
# 
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
# OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
# HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
# WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
# OTHER DEALINGS IN THE SOFTWARE.

require 'rake'
require 'rake/testtask'
require 'rake/rdoctask'
require 'lib/container_logger'


task :todo do
  # A probably controversial way of achieving different task effects
  @task_captures = @legend =  ""
  {:todo => :green, :fixme => :blue, :bug => "red blink"}.each do |task, eff|
    @task_captures += "#{task}|"
    
    methods = eff.to_s.split(/[\.\s]/).map{|e| ".console_#{e}" }.join().to_a.map {|e| 
      "def #{task}; self#{e}; end; "
    }.join()
    eval(%{class String; #{methods} end})
    
    @legend += eval(%{"#{task.to_s.upcase} ".#{task}})
  end
  @task_captures.gsub!(/(.)$/, "")
  puts ("Legend:".console_bold)+" #{@legend}"
  puts ""
  
  tasks = files = 0
  %w{. app config test lib}.each do |dir|
    Dir.entries(dir).each do |entry|
      next unless entry =~ /\.rb$/i
      files   += 1
      f_tasks  = 0
      
      (lines = IO.readlines("#{dir}/#{entry}")).each_with_index do |line, i|
        next if i==0 || i==(lines.size-1) || line.empty?
        
        next unless line.match(/^[\s]*\#.*?(#{@task_captures})[\s\:]*?([^\s\:].+?)$/i)
        
        puts eval(%{'#{$2}'.#{$1.downcase}()}).to_s + " on line: #{i}"
        puts "   \e[1mline before: \e[0m#{lines[i-1].chomp}" if (lines[i-1].gsub(/[\s\#]/, "") || "").size > 0
        puts "   \e[1mline after: \e[0m#{lines[i+1].gsub!(/^[\s\#]*/, "")}"
        tasks   += 1
        f_tasks += 1
      end
      puts "#{f_tasks} task(s) in total for #{dir}/#{entry}\n".console_bold if f_tasks > 0
    end
  end
  puts "#{tasks} tasks over #{files} files".console_dark_yellow
end

task :lines do
  lines = 0
  files = 0
  %w{. app config lib contained/core/deployer/app contained/management/webinterface/app/controllers contained/management/webinterface/app/models}.each do |dir|
    Dir.entries(dir).each do |entry|
      next unless entry =~ /\.rb$/i
      files += 1
      f      = File.new("#{dir}/#{entry}")
      m      = f.read().scan(/^[\s]*?[^#].+?$/i)
      lines += m.size
      f.close()
    end
  end
  puts "Total number lines of code over #{files} files: #{lines}".console_dark_yellow
end

task :test do
  
end

task :rdoc do
  
end

task :default => :todo


class String
  def todo;   self.console_green;   end
  def fixme;  self.console_blue;  end
end